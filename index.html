<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            color: white;
        }

        .arjs-loader-text {
            font-size: 0.75em;
            margin-top: 0.5em;
        }

        #qr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .qr-detected {
            position: absolute;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        /* Clean video and canvas positioning without viewport interference */
        video {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            object-fit: cover !important;
            z-index: -1 !important;
        }

        canvas {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            object-fit: cover !important;
        }

        a-scene {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            overflow: hidden !important;
        }

        /* Mobile viewport optimization */
        @media (max-width: 768px) {
            body {
                overflow: hidden !important;
            }
        }
    </style>
</head>

<body style="margin: 0px; overflow: hidden;">
    <div class="arjs-loader">
        <div>
            <div>Loading AR Camera...</div>
            <div class="arjs-loader-text">Point your camera at any QR code to see the 3D model</div>
        </div>
    </div>

    <!-- Gyroscope permission button (iOS) -->
    <div id="gyro-permission"
        style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
        <div style="color: white; margin-bottom: 15px;">Enable device rotation for better AR experience?</div>
        <button id="enable-gyro"
            style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Enable
            Rotation</button>
        <button id="skip-gyro"
            style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Skip</button>
    </div>

    <!-- QR Detection Overlay -->
    <div id="qr-overlay"></div>

    <a-scene vr-mode-ui="enabled: false;" renderer="logarithmicDepthBuffer: true;" embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; sourceWidth: 320; sourceHeight: 240; displayWidth: 320; displayHeight: 240;">

        <!-- Multiple barcode markers for different QR codes -->
        <a-marker type="barcode" value="0">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="1 1 1" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="1">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="2">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Hiro marker for testing -->
        <a-marker preset="hiro">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Pattern marker removed due to file issues -->

        <!-- Camera with AR.js built-in tracking -->
        <a-entity id="ar-camera" camera="fov: 140; zoom: 0.2; near: 0.05; far: 2000"></a-entity>
    </a-scene>

    <script>
        let qrDetectionActive = false;
        let videoElement = null;
        let canvas = null;
        let context = null;
        let arModel = null;
        let qrModelVisible = false;
        let modelFixed = false; // Track if model is already placed and fixed
        let animationUpdateLoop = null; // Animation update loop
        let gyroscopeActive = false; // Track gyroscope status
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 }; // Device orientation data
        let cameraEntity = null; // Reference to camera entity
        let markerTrackingActive = false; // Track if marker-based AR is active
        let virtualMarker = null; // Virtual marker for AR tracking
        let deviceZoomLevel = 0.3; // Dynamic zoom level based on device

        // Detect device type and set appropriate zoom level
        function detectDeviceAndSetZoom() {
            const userAgent = navigator.userAgent.toLowerCase();
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const pixelRatio = window.devicePixelRatio || 1;

            console.log(`Device info: ${screenWidth}x${screenHeight}, ratio: ${pixelRatio}, UA: ${userAgent.substring(0, 50)}...`);

            // iPhone specific adjustments
            if (userAgent.includes('iphone')) {
                if (screenWidth >= 414) { // iPhone Plus/Pro Max models
                    deviceZoomLevel = 0.15; // Very zoomed out
                } else if (screenWidth >= 375) { // iPhone 6/7/8/X/11/12/13 standard
                    deviceZoomLevel = 0.2; // Moderately zoomed out
                } else { // iPhone SE and older
                    deviceZoomLevel = 0.25; // Less zoomed out
                }
            }
            // iPad adjustments
            else if (userAgent.includes('ipad')) {
                deviceZoomLevel = 0.4; // iPads need less zoom out
            }
            // Samsung Galaxy adjustments
            else if (userAgent.includes('samsung') || userAgent.includes('galaxy')) {
                if (screenWidth >= 480) { // Large Samsung phones
                    deviceZoomLevel = 0.1; // Extremely zoomed out
                } else if (screenWidth >= 360) { // Standard Samsung phones
                    deviceZoomLevel = 0.15; // Very zoomed out
                } else { // Smaller Samsung phones
                    deviceZoomLevel = 0.2; // Moderately zoomed out
                }
            }
            // Google Pixel adjustments
            else if (userAgent.includes('pixel')) {
                deviceZoomLevel = 0.15; // Pixels tend to zoom in a lot
            }
            // OnePlus adjustments
            else if (userAgent.includes('oneplus')) {
                deviceZoomLevel = 0.12; // OnePlus phones zoom in significantly
            }
            // Xiaomi adjustments
            else if (userAgent.includes('xiaomi') || userAgent.includes('mi ')) {
                deviceZoomLevel = 0.18; // Xiaomi phones need aggressive zoom out
            }
            // Huawei adjustments
            else if (userAgent.includes('huawei')) {
                deviceZoomLevel = 0.16; // Huawei phones zoom in quite a bit
            }
            // Realme adjustments
            else if (userAgent.includes('realme')) {
                if (screenWidth >= 480) { // Realme Pro/flagship models
                    deviceZoomLevel = 0.08; // Extremely zoomed out - Realme zooms in heavily
                } else if (screenWidth >= 360) { // Standard Realme phones
                    deviceZoomLevel = 0.12; // Very zoomed out
                } else { // Budget Realme phones
                    deviceZoomLevel = 0.18; // Moderately zoomed out
                }
            }
            // High pixel density devices (general)
            else if (pixelRatio >= 3) {
                deviceZoomLevel = 0.1; // Very high DPI devices need extreme zoom out
            }
            else if (pixelRatio >= 2) {
                deviceZoomLevel = 0.2; // High DPI devices need significant zoom out
            }
            // Large screen devices
            else if (screenWidth >= 480) {
                deviceZoomLevel = 0.15; // Large screens often zoom in too much
            }
            // Small screen devices
            else if (screenWidth <= 320) {
                deviceZoomLevel = 0.35; // Small screens need less zoom out
            }
            // Default for unknown devices
            else {
                deviceZoomLevel = 0.25; // Conservative default
            }

            console.log(`Selected zoom level: ${deviceZoomLevel}`);
        }

        // Initialize QR detection with device-specific camera settings
        function initQRDetection() {
            // Detect device and set appropriate zoom level
            detectDeviceAndSetZoom();

            // Request wide-angle camera first
            requestHighQualityCamera();

            setTimeout(() => {
                videoElement = document.querySelector('video');
                if (videoElement) {
                    // Set optimized video attributes without viewport interference
                    videoElement.setAttribute('width', '640');
                    videoElement.setAttribute('height', '480');
                    videoElement.style.objectFit = 'cover'; // Prevent stretching

                    // Apply device-specific camera settings via AR.js instead of CSS transforms
                    updateARCameraSettings(deviceZoomLevel);

                    console.log(`Applied camera settings for device: ${navigator.userAgent.substring(0, 50)}...`);

                    canvas = document.createElement('canvas');
                    context = canvas.getContext('2d', { willReadFrequently: true });

                    // Create AR model for QR detection
                    createQRARModel();

                    // Get camera entity reference
                    cameraEntity = document.querySelector('#ar-camera');

                    qrDetectionActive = true;
                    detectQR();
                }
            }, 3000);
        }

        // Update AR camera settings without interfering with viewport
        function updateARCameraSettings(zoomLevel) {
            const scene = document.querySelector('a-scene');
            const camera = document.querySelector('#ar-camera');

            if (camera) {
                // Calculate appropriate FOV based on zoom level (inverse relationship)
                const baseFOV = 80; // Standard FOV
                const adjustedFOV = baseFOV + (zoomLevel * 200); // Higher zoom = wider FOV

                // Update camera FOV instead of using CSS transforms
                camera.setAttribute('camera', `fov: ${adjustedFOV}; near: 0.05; far: 2000`);

                console.log(`Updated camera FOV to ${adjustedFOV}° for zoom level ${zoomLevel}`);
            }

            // Update AR.js source settings for better tracking
            if (scene) {
                const currentArjs = scene.getAttribute('arjs');
                const updatedArjs = currentArjs.replace(/sourceWidth: \d+/, `sourceWidth: ${Math.floor(640 * (1 + zoomLevel))}`);
                scene.setAttribute('arjs', updatedArjs);
            }
        }

        // Request wide-angle camera stream (simplified constraints)
        function requestHighQualityCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        width: { ideal: 640, min: 480 },
                        height: { ideal: 480, min: 360 },
                        facingMode: { ideal: 'environment' }, // Back camera
                        frameRate: { ideal: 20, min: 10 },
                        aspectRatio: { ideal: 4 / 3 }
                    }
                };

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function (stream) {
                        console.log('Wide-angle camera stream obtained');

                        // Try to apply basic settings without zoom constraints
                        const videoTrack = stream.getVideoTracks()[0];
                        if (videoTrack && videoTrack.applyConstraints) {
                            videoTrack.applyConstraints({
                                focusMode: 'continuous'
                            }).catch(err => console.log('Focus constraint failed:', err));
                        }
                    })
                    .catch(function (error) {
                        console.log('Camera access error:', error);
                        // Fallback to basic constraints
                        navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: 'environment'
                            }
                        }).then(stream => {
                            console.log('Fallback camera stream obtained');
                        }).catch(err => console.log('Fallback camera failed:', err));
                    });
            }
        }

        // Create clean AR model system (5% scale, QR as base)
        function createQRARModel() {
            const scene = document.querySelector('a-scene');

            // Create a dynamic marker that we'll position based on QR detection
            arModel = document.createElement('a-entity');
            arModel.setAttribute('id', 'dynamic-qr-3d-model');
            arModel.setAttribute('visible', 'false');

            // Add the actual GLTF model at 5% scale with correct orientation
            const gltfModel = document.createElement('a-entity');
            gltfModel.setAttribute('gltf-model', './officeman_laptop_2.glb');
            gltfModel.setAttribute('scale', '0.05 0.05 0.05'); // 5% scale as requested
            gltfModel.setAttribute('position', '0 0 0'); // Bottom sits on QR code (Y=0)
            gltfModel.setAttribute('rotation', '0 0 180'); // Try Z-axis rotation for top view
            // Enhanced animation-mixer for video textures and complex animations
            gltfModel.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1; crossFadeDuration: 0');

            // Add error handling for GLTF loading and video texture setup
            gltfModel.addEventListener('model-loaded', function () {
                console.log('GLTF model loaded - setting up video textures and animations');

                setTimeout(() => {
                    const object3D = gltfModel.getObject3D('mesh');
                    if (object3D) {
                        // Enable video textures and animations
                        setupVideoTextures(object3D);
                        setupAnimations(gltfModel, object3D);
                    }
                }, 100);
            });

            gltfModel.addEventListener('model-error', function (event) {
                console.error('GLTF model failed to load:', event.detail);
            });

            arModel.appendChild(gltfModel);

            scene.appendChild(arModel);
            console.log('Clean AR model system initialized - 5% scale, QR as base');
        }

        // Setup video textures in GLB model
        function setupVideoTextures(object3D) {
            object3D.traverse(function (child) {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(material => {
                        // Check for video textures
                        if (material.map && material.map.image && material.map.image.tagName === 'VIDEO') {
                            const video = material.map.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Video texture found and started');
                        }

                        // Check for emissive video textures
                        if (material.emissiveMap && material.emissiveMap.image && material.emissiveMap.image.tagName === 'VIDEO') {
                            const video = material.emissiveMap.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Emissive video texture found and started');
                        }

                        // Enable video texture updates
                        if (material.map && material.map.isVideoTexture) {
                            material.map.needsUpdate = true;
                        }
                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                            material.emissiveMap.needsUpdate = true;
                        }
                    });
                }
            });
        }

        // Setup animations for GLB model
        function setupAnimations(gltfEntity, object3D) {
            // Wait a bit more for animation-mixer to initialize
            setTimeout(() => {
                const mixer = gltfEntity.components['animation-mixer'];

                if (mixer && mixer.mixer) {
                    console.log('Animation mixer found, setting up animations...');

                    // Start all animations
                    const actions = mixer.mixer._actions;
                    if (actions && actions.length > 0) {
                        actions.forEach(action => {
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity); // THREE.LoopRepeat
                            console.log('Animation started:', action._clip.name);
                        });
                        mixer.mixer.timeScale = 1;
                    } else {
                        console.log('No animation actions found, checking clips...');

                        // Try to access clips directly from the loaded model
                        if (object3D.animations && object3D.animations.length > 0) {
                            console.log('Found', object3D.animations.length, 'animation clips');

                            // Create new mixer with all clips
                            const newMixer = new THREE.AnimationMixer(object3D);
                            object3D.animations.forEach(clip => {
                                const action = newMixer.clipAction(clip);
                                action.reset();
                                action.play();
                                action.setLoop(2201, Infinity);
                                console.log('Clip started:', clip.name);
                            });

                            // Replace the mixer in the component
                            mixer.mixer = newMixer;
                            console.log('New animation mixer created with', object3D.animations.length, 'clips');
                        }
                    }
                } else {
                    console.log('No animation mixer component found, trying to create one...');

                    // Try to manually create animation mixer
                    if (object3D.animations && object3D.animations.length > 0) {
                        console.log('Creating manual animation mixer for', object3D.animations.length, 'clips');

                        const manualMixer = new THREE.AnimationMixer(object3D);
                        object3D.animations.forEach(clip => {
                            const action = manualMixer.clipAction(clip);
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity);
                            console.log('Manual clip started:', clip.name);
                        });

                        // Store the mixer for updates
                        gltfEntity.manualMixer = manualMixer;
                    }
                }
            }, 1000);
        }

        // Start continuous update loop for animations and video textures
        function startAnimationUpdateLoop() {
            if (animationUpdateLoop) return; // Already running

            function updateLoop() {
                if (arModel && qrModelVisible) {
                    const gltfModel = arModel.querySelector('[gltf-model]');
                    if (gltfModel) {
                        // Update official animation mixer
                        const mixer = gltfModel.components['animation-mixer'];
                        if (mixer && mixer.mixer) {
                            mixer.mixer.update(0.016); // ~60fps
                        }

                        // Update manual mixer if it exists
                        if (gltfModel.manualMixer) {
                            gltfModel.manualMixer.update(0.016);
                        }

                        // Update video textures
                        const object3D = gltfModel.getObject3D('mesh');
                        if (object3D) {
                            object3D.traverse(function (child) {
                                if (child.isMesh && child.material) {
                                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                                    materials.forEach(material => {
                                        if (material.map && material.map.isVideoTexture) {
                                            material.map.needsUpdate = true;
                                        }
                                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                                            material.emissiveMap.needsUpdate = true;
                                        }
                                    });
                                }
                            });
                        }
                    }
                }

                animationUpdateLoop = requestAnimationFrame(updateLoop);
            }

            updateLoop();
            console.log('Animation update loop started');
        }

        // Enable marker-based AR tracking (no gyroscope needed)
        function enableMarkerARTracking() {
            if (markerTrackingActive) return; // Already active

            // Create virtual marker at QR location for AR tracking
            createVirtualMarker();
            markerTrackingActive = true;
            console.log('Marker-based AR tracking enabled - no gyroscope needed');
        }

        // Create marker-based AR tracking using AR.js
        function createVirtualMarker() {
            if (!arModel || !arModel.worldPosition) return;

            // Use AR.js built-in marker tracking - model stays world-locked
            // The AR.js system handles all the camera tracking automatically

            // Make model responsive to camera position using look-at
            arModel.setAttribute('look-at', '#ar-camera');

            // Add smooth rotation animation to make model more dynamic
            arModel.setAttribute('animation__rotate', {
                property: 'rotation',
                to: '0 360 0',
                dur: 20000,
                loop: true,
                easing: 'linear'
            });

            console.log('AR.js marker tracking enabled - model will follow camera naturally');
        }

        // Start AR world tracking with full 360° support
        function startARWorldTracking() {
            // Record initial orientation when model is placed
            initialOrientation = {
                alpha: deviceOrientation.alpha || 0,
                beta: deviceOrientation.beta || 0,
                gamma: deviceOrientation.gamma || 0
            };

            // Enable high-frequency orientation updates for smooth AR
            window.addEventListener('deviceorientation', handleDeviceOrientation, true);

            // Also listen for device motion for better tracking
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleDeviceMotion, true);
            }

            worldTrackingActive = true;
            console.log('AR world tracking enabled with full 360° support');
            console.log('Initial orientation:', initialOrientation);
        }

        // Handle device motion for enhanced AR tracking
        function handleDeviceMotion(event) {
            if (!worldTrackingActive) return;

            // Device motion can provide additional smoothing for AR tracking
            // This helps with small movements and stabilization
        }

        // Handle device orientation changes for AR world tracking
        function handleDeviceOrientation(event) {
            // Get current orientation values
            deviceOrientation.alpha = event.alpha || 0; // Z axis (compass)
            deviceOrientation.beta = event.beta || 0;   // X axis (front-back tilt)
            deviceOrientation.gamma = event.gamma || 0; // Y axis (left-right tilt)

            // Update camera to create AR world tracking effect
            if (worldTrackingActive && cameraEntity) {
                updateARCamera();
            }
        }

        // Update AR camera for full 360° world tracking
        function updateARCamera() {
            if (!cameraEntity || !worldTrackingActive) return;

            // Use absolute device orientation for full 360° tracking
            // This creates proper AR world tracking where you can walk around the model

            // Convert device orientation to camera rotation for natural AR experience
            let cameraRotationX = -deviceOrientation.beta; // Up/down tilt (invert for natural feel)
            let cameraRotationY = deviceOrientation.alpha; // Left/right rotation (compass)
            let cameraRotationZ = deviceOrientation.gamma; // Side tilt

            // Handle compass wrap-around (0° to 360°)
            if (cameraRotationY < 0) {
                cameraRotationY += 360;
            }

            // Apply sensitivity adjustments for smooth movement
            cameraRotationX *= 0.7; // Reduce up/down sensitivity slightly
            cameraRotationY *= 0.8; // Reduce left/right sensitivity slightly  
            cameraRotationZ *= 0.4; // Reduce tilt sensitivity significantly

            // Clamp extreme rotations for stability
            cameraRotationX = Math.max(-85, Math.min(85, cameraRotationX)); // Prevent over-tilting

            // Update camera rotation for full AR world tracking
            cameraEntity.setAttribute('rotation', `${cameraRotationX} ${cameraRotationY} ${cameraRotationZ}`);

            // Debug log for troubleshooting (remove in production)
            if (Math.random() < 0.01) { // Log occasionally to avoid spam
                console.log(`Camera rotation: X:${cameraRotationX.toFixed(1)}° Y:${cameraRotationY.toFixed(1)}° Z:${cameraRotationZ.toFixed(1)}°`);
            }
        }

        // Model uses AR.js built-in tracking - no manual rotation needed
        function updateModelRotation() {
            // AR.js handles all tracking automatically
            // Model stays world-locked using AR.js marker system
            // look-at component makes model face camera naturally
            return;
        }

        // Fallback rotation if gyroscope is not available
        function addFallbackRotation() {
            if (!arModel) return;

            // Set base rotation for top-down view, then add rotation animation
            arModel.setAttribute('rotation', ' 0 180'); // Top-down view first
            arModel.setAttribute('animation__gyro-fallback', {
                property: 'rotation',
                to: '0 360 180', // Maintain top view while rotating around Y-axis
                dur: 15000,
                loop: true,
                easing: 'linear'
            });

            console.log('Using fallback rotation animation');
        }

        // Stop gyroscope rotation (when model is hidden)
        function stopGyroscopeRotation() {
            if (gyroscopeActive) {
                window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
                gyroscopeActive = false;
                console.log('Gyroscope rotation disabled');
            }
        }

        // Place model on QR location (persistent until next QR detection)
        function createDynamicARMarker(location) {
            if (!arModel) return;

            // Only reposition if model is not already fixed in place
            if (!modelFixed) {
                // Calculate QR center position
                const centerX = (location.topLeftCorner.x + location.topRightCorner.x) / 2;
                const centerY = (location.topLeftCorner.y + location.bottomLeftCorner.y) / 2;
                const qrWidth = location.topRightCorner.x - location.topLeftCorner.x;

                // Convert screen coordinates to world coordinates
                const normalizedX = (centerX / canvas.width - 0.5) * 2;
                const normalizedY = -(centerY / canvas.height - 0.5) * 2;

                // Calculate distance for optimal visibility
                const distance = Math.max(1.2, 180 / qrWidth);

                // Position in 3D world - QR code as base
                const worldX = normalizedX * 0.4;
                const worldY = normalizedY * 0.4;
                const worldZ = -distance;

                // Store world position for tracking
                arModel.worldPosition = { x: worldX, y: worldY, z: worldZ };

                // Position and show the 3D model (bottom sits on QR)
                arModel.setAttribute('position', `${worldX} ${worldY} ${worldZ}`);
                arModel.setAttribute('visible', 'true');

                // Mark model as fixed in place
                modelFixed = true;
                qrModelVisible = true;

                // Start animation update loop for video textures
                startAnimationUpdateLoop();

                // Enable marker-based AR tracking (no gyroscope needed)
                enableMarkerARTracking();

                console.log(`3D Model fixed at QR location: ${worldX}, ${worldY}, ${worldZ}`);
            }

            // Clear any overlay elements (no dot, no text)
            document.getElementById('qr-overlay').innerHTML = '';
        }

        // QR Code detection function with memory optimization
        function detectQR() {
            if (!qrDetectionActive || !videoElement) {
                requestAnimationFrame(detectQR);
                return;
            }

            try {
                // Limit canvas size for memory efficiency
                const maxWidth = 640;
                const maxHeight = 480;

                canvas.width = Math.min(videoElement.videoWidth, maxWidth);
                canvas.height = Math.min(videoElement.videoHeight, maxHeight);

                if (canvas.width > 0 && canvas.height > 0) {
                    context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

                    // Only process every other frame to reduce memory usage
                    if (Date.now() % 2 === 0) {
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                        if (typeof jsQR !== 'undefined') {
                            const code = jsQR(imageData.data, imageData.width, imageData.height);

                            if (code) {
                                console.log('QR Code detected:', code.data);
                                showQRDetection(code.location);
                                showARModelOnQR(code.location);
                            } else {
                                // Don't hide model when QR is lost - keep it persistent
                                hideQRDetection();
                                // Model stays visible and fixed in place
                            }
                        }
                    }
                }
            } catch (error) {
                console.log('QR detection error:', error);
            }

            // Reduce frame rate to save memory
            setTimeout(() => {
                requestAnimationFrame(detectQR);
            }, 50); // ~20 FPS instead of 60 FPS
        }

        function showQRDetection(location) {
            // Now we'll create a proper AR marker at the QR location
            createDynamicARMarker(location);
        }

        function hideQRDetection() {
            document.getElementById('qr-overlay').innerHTML = '';
            // Model stays visible and fixed - no hiding when QR is lost
        }

        function showARModelOnQR(location) {
            // Reset model position when new QR is detected
            if (modelFixed) {
                modelFixed = false; // Allow repositioning for new QR detection
                console.log('New QR detected - repositioning model');
            }
        }

        function hideARModel() {
            if (qrModelVisible) {
                qrModelVisible = false;
                console.log('3D Model hidden');
            }
        }

        // Hide loader when AR is ready
        window.addEventListener('load', function () {
            const loader = document.querySelector('.arjs-loader');

            setTimeout(() => {
                if (loader) {
                    loader.style.display = 'none';
                }
                initQRDetection();
            }, 2000);
        });

        // Add marker found/lost events
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(() => {
                const markers = document.querySelectorAll('a-marker');
                markers.forEach(marker => {
                    marker.addEventListener('markerFound', function () {
                        console.log('Marker detected!');
                    });

                    marker.addEventListener('markerLost', function () {
                        console.log('Marker lost');
                    });
                });
            }, 1000);
        });
    </script>
</body>

</html>