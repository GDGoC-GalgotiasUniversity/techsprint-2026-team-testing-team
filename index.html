<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            color: white;
        }

        .arjs-loader-text {
            font-size: 0.75em;
            margin-top: 0.5em;
        }

        #qr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .qr-detected {
            position: absolute;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        /* Aggressive mobile camera zoom fix */
        video {
            object-fit: cover !important;
            transform: scale(0.3) !important;
            transform-origin: center center !important;
            width: 100% !important;
            height: 100% !important;
        }

        canvas {
            transform: scale(0.4) !important;
            transform-origin: center center !important;
        }

        /* Maximum zoom out for mobile devices */
        @media (max-width: 768px) {
            video {
                transform: scale(0.2) !important;
            }

            canvas {
                transform: scale(0.25) !important;
            }
        }

        /* Force full viewport usage */
        a-scene {
            width: 100vw !important;
            height: 100vh !important;
        }

        /* Wide camera view settings */
        video {
            object-fit: cover !important;
            transform: scale(0.9) !important;
            /* Zoom out slightly */
        }

        a-scene {
            width: 100% !important;
            height: 100% !important;
        }

        canvas {
            object-fit: cover !important;
        }
    </style>
</head>

<body style="margin: 0px; overflow: hidden;">
    <div class="arjs-loader">
        <div>
            <div>Loading AR Camera...</div>
            <div class="arjs-loader-text">Point your camera at any QR code to see the 3D model</div>
        </div>
    </div>

    <!-- Gyroscope permission button (iOS) -->
    <div id="gyro-permission"
        style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
        <div style="color: white; margin-bottom: 15px;">Enable device rotation for better AR experience?</div>
        <button id="enable-gyro"
            style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Enable
            Rotation</button>
        <button id="skip-gyro"
            style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Skip</button>
    </div>

    <!-- QR Detection Overlay -->
    <div id="qr-overlay"></div>

    <a-scene vr-mode-ui="enabled: false;" renderer="logarithmicDepthBuffer: true;" embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; sourceWidth: 320; sourceHeight: 240; displayWidth: 320; displayHeight: 240;">

        <!-- Multiple barcode markers for different QR codes -->
        <a-marker type="barcode" value="0">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="1 1 1" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="1">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="2">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Hiro marker for testing -->
        <a-marker preset="hiro">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Pattern marker removed due to file issues -->

        <!-- Camera with maximum wide view for mobile -->
        <a-entity id="ar-camera" camera="fov: 140; zoom: 0.2; near: 0.05; far: 2000" look-controls="enabled: false"
            wasd-controls="enabled: false"></a-entity>
    </a-scene>

    <script>
        let qrDetectionActive = false;
        let videoElement = null;
        let canvas = null;
        let context = null;
        let arModel = null;
        let qrModelVisible = false;
        let modelFixed = false; // Track if model is already placed and fixed
        let animationUpdateLoop = null; // Animation update loop
        let gyroscopeActive = false; // Track gyroscope status
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 }; // Device orientation data
        let initialOrientation = { alpha: 0, beta: 0, gamma: 0 }; // Initial orientation when model is placed
        let cameraEntity = null; // Reference to camera entity
        let worldTrackingActive = false; // Track if world tracking is active

        // Initialize QR detection with high-quality camera
        function initQRDetection() {
            // Request high-quality camera first
            requestHighQualityCamera();

            setTimeout(() => {
                videoElement = document.querySelector('video');
                if (videoElement) {
                    // Set optimized video attributes with wide view
                    videoElement.setAttribute('width', '640');
                    videoElement.setAttribute('height', '480');
                    videoElement.style.objectFit = 'cover'; // Prevent stretching
                    videoElement.style.transform = 'scale(0.3)'; // Extremely wide view for mobile QR scanning
                    videoElement.style.transformOrigin = 'center center'; // Scale from center

                    canvas = document.createElement('canvas');
                    context = canvas.getContext('2d', { willReadFrequently: true });

                    // Create AR model for QR detection
                    createQRARModel();

                    // Get camera entity reference
                    cameraEntity = document.querySelector('#ar-camera');

                    qrDetectionActive = true;
                    detectQR();
                }
            }, 3000);
        }

        // Request wide-angle camera stream (simplified constraints)
        function requestHighQualityCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        width: { ideal: 640, min: 480 },
                        height: { ideal: 480, min: 360 },
                        facingMode: { ideal: 'environment' }, // Back camera
                        frameRate: { ideal: 20, min: 10 },
                        aspectRatio: { ideal: 4 / 3 }
                    }
                };

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function (stream) {
                        console.log('Wide-angle camera stream obtained');

                        // Try to apply basic settings without zoom constraints
                        const videoTrack = stream.getVideoTracks()[0];
                        if (videoTrack && videoTrack.applyConstraints) {
                            videoTrack.applyConstraints({
                                focusMode: 'continuous'
                            }).catch(err => console.log('Focus constraint failed:', err));
                        }
                    })
                    .catch(function (error) {
                        console.log('Camera access error:', error);
                        // Fallback to basic constraints
                        navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: 'environment'
                            }
                        }).then(stream => {
                            console.log('Fallback camera stream obtained');
                        }).catch(err => console.log('Fallback camera failed:', err));
                    });
            }
        }

        // Create clean AR model system (5% scale, QR as base)
        function createQRARModel() {
            const scene = document.querySelector('a-scene');

            // Create a dynamic marker that we'll position based on QR detection
            arModel = document.createElement('a-entity');
            arModel.setAttribute('id', 'dynamic-qr-3d-model');
            arModel.setAttribute('visible', 'false');

            // Add the actual GLTF model at 5% scale with correct orientation
            const gltfModel = document.createElement('a-entity');
            gltfModel.setAttribute('gltf-model', './officeman_laptop_2.glb');
            gltfModel.setAttribute('scale', '0.05 0.05 0.05'); // 5% scale as requested
            gltfModel.setAttribute('position', '0 0 0'); // Bottom sits on QR code (Y=0)
            gltfModel.setAttribute('rotation', '0 0 180'); // Try Z-axis rotation for top view
            // Enhanced animation-mixer for video textures and complex animations
            gltfModel.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1; crossFadeDuration: 0');

            // Add error handling for GLTF loading and video texture setup
            gltfModel.addEventListener('model-loaded', function () {
                console.log('GLTF model loaded - setting up video textures and animations');

                setTimeout(() => {
                    const object3D = gltfModel.getObject3D('mesh');
                    if (object3D) {
                        // Enable video textures and animations
                        setupVideoTextures(object3D);
                        setupAnimations(gltfModel, object3D);
                    }
                }, 100);
            });

            gltfModel.addEventListener('model-error', function (event) {
                console.error('GLTF model failed to load:', event.detail);
            });

            arModel.appendChild(gltfModel);

            scene.appendChild(arModel);
            console.log('Clean AR model system initialized - 5% scale, QR as base');
        }

        // Setup video textures in GLB model
        function setupVideoTextures(object3D) {
            object3D.traverse(function (child) {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(material => {
                        // Check for video textures
                        if (material.map && material.map.image && material.map.image.tagName === 'VIDEO') {
                            const video = material.map.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Video texture found and started');
                        }

                        // Check for emissive video textures
                        if (material.emissiveMap && material.emissiveMap.image && material.emissiveMap.image.tagName === 'VIDEO') {
                            const video = material.emissiveMap.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Emissive video texture found and started');
                        }

                        // Enable video texture updates
                        if (material.map && material.map.isVideoTexture) {
                            material.map.needsUpdate = true;
                        }
                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                            material.emissiveMap.needsUpdate = true;
                        }
                    });
                }
            });
        }

        // Setup animations for GLB model
        function setupAnimations(gltfEntity, object3D) {
            // Wait a bit more for animation-mixer to initialize
            setTimeout(() => {
                const mixer = gltfEntity.components['animation-mixer'];

                if (mixer && mixer.mixer) {
                    console.log('Animation mixer found, setting up animations...');

                    // Start all animations
                    const actions = mixer.mixer._actions;
                    if (actions && actions.length > 0) {
                        actions.forEach(action => {
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity); // THREE.LoopRepeat
                            console.log('Animation started:', action._clip.name);
                        });
                        mixer.mixer.timeScale = 1;
                    } else {
                        console.log('No animation actions found, checking clips...');

                        // Try to access clips directly from the loaded model
                        if (object3D.animations && object3D.animations.length > 0) {
                            console.log('Found', object3D.animations.length, 'animation clips');

                            // Create new mixer with all clips
                            const newMixer = new THREE.AnimationMixer(object3D);
                            object3D.animations.forEach(clip => {
                                const action = newMixer.clipAction(clip);
                                action.reset();
                                action.play();
                                action.setLoop(2201, Infinity);
                                console.log('Clip started:', clip.name);
                            });

                            // Replace the mixer in the component
                            mixer.mixer = newMixer;
                            console.log('New animation mixer created with', object3D.animations.length, 'clips');
                        }
                    }
                } else {
                    console.log('No animation mixer component found, trying to create one...');

                    // Try to manually create animation mixer
                    if (object3D.animations && object3D.animations.length > 0) {
                        console.log('Creating manual animation mixer for', object3D.animations.length, 'clips');

                        const manualMixer = new THREE.AnimationMixer(object3D);
                        object3D.animations.forEach(clip => {
                            const action = manualMixer.clipAction(clip);
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity);
                            console.log('Manual clip started:', clip.name);
                        });

                        // Store the mixer for updates
                        gltfEntity.manualMixer = manualMixer;
                    }
                }
            }, 1000);
        }

        // Start continuous update loop for animations and video textures
        function startAnimationUpdateLoop() {
            if (animationUpdateLoop) return; // Already running

            function updateLoop() {
                if (arModel && qrModelVisible) {
                    const gltfModel = arModel.querySelector('[gltf-model]');
                    if (gltfModel) {
                        // Update official animation mixer
                        const mixer = gltfModel.components['animation-mixer'];
                        if (mixer && mixer.mixer) {
                            mixer.mixer.update(0.016); // ~60fps
                        }

                        // Update manual mixer if it exists
                        if (gltfModel.manualMixer) {
                            gltfModel.manualMixer.update(0.016);
                        }

                        // Update video textures
                        const object3D = gltfModel.getObject3D('mesh');
                        if (object3D) {
                            object3D.traverse(function (child) {
                                if (child.isMesh && child.material) {
                                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                                    materials.forEach(material => {
                                        if (material.map && material.map.isVideoTexture) {
                                            material.map.needsUpdate = true;
                                        }
                                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                                            material.emissiveMap.needsUpdate = true;
                                        }
                                    });
                                }
                            });
                        }
                    }
                }

                animationUpdateLoop = requestAnimationFrame(updateLoop);
            }

            updateLoop();
            console.log('Animation update loop started');
        }

        // Enable AR world tracking system
        function enableARWorldTracking() {
            if (worldTrackingActive) return; // Already active

            // Check if permission is needed (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                // Show permission dialog
                showGyroPermissionDialog();
            } else {
                // Android or older iOS - no permission needed
                startARWorldTracking();
            }
        }

        // Show gyroscope permission dialog
        function showGyroPermissionDialog() {
            const permissionDiv = document.getElementById('gyro-permission');
            permissionDiv.style.display = 'block';

            document.getElementById('enable-gyro').onclick = function () {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            startARWorldTracking();
                        } else {
                            console.log('Device orientation permission denied');
                        }
                        permissionDiv.style.display = 'none';
                    })
                    .catch(error => {
                        console.log('Device orientation permission error:', error);
                        permissionDiv.style.display = 'none';
                    });
            };

            document.getElementById('skip-gyro').onclick = function () {
                permissionDiv.style.display = 'none';
            };
        }

        // Start AR world tracking
        function startARWorldTracking() {
            // Record initial orientation when model is placed
            initialOrientation = { ...deviceOrientation };

            window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            worldTrackingActive = true;
            console.log('AR world tracking enabled');
        }

        // Handle device orientation changes for AR world tracking
        function handleDeviceOrientation(event) {
            // Get current orientation values
            deviceOrientation.alpha = event.alpha || 0; // Z axis (compass)
            deviceOrientation.beta = event.beta || 0;   // X axis (front-back tilt)
            deviceOrientation.gamma = event.gamma || 0; // Y axis (left-right tilt)

            // Update camera to create AR world tracking effect
            if (worldTrackingActive && cameraEntity) {
                updateARCamera();
            }
        }

        // Update AR camera for world tracking (model stays fixed, camera moves)
        function updateARCamera() {
            if (!cameraEntity || !worldTrackingActive) return;

            // Calculate rotation difference from initial position
            const deltaAlpha = deviceOrientation.alpha - initialOrientation.alpha;
            const deltaBeta = deviceOrientation.beta - initialOrientation.beta;
            const deltaGamma = deviceOrientation.gamma - initialOrientation.gamma;

            // Apply camera rotation to simulate looking around the AR model
            const cameraRotationX = -deltaBeta * 0.8; // Up/down look
            const cameraRotationY = deltaAlpha * 0.8;  // Left/right look
            const cameraRotationZ = -deltaGamma * 0.3; // Tilt compensation

            // Update camera rotation for AR world tracking
            cameraEntity.setAttribute('rotation', `${cameraRotationX} ${cameraRotationY} ${cameraRotationZ}`);
        }

        // Keep model fixed in world space (no rotation needed - camera does the work)
        function updateModelRotation() {
            // Model stays completely static in world coordinates
            // Camera movement creates the AR effect of looking around the model
            return; // No model rotation needed
        }

        // Fallback rotation if gyroscope is not available
        function addFallbackRotation() {
            if (!arModel) return;

            // Set base rotation for top-down view, then add rotation animation
            arModel.setAttribute('rotation', ' 0 180'); // Top-down view first
            arModel.setAttribute('animation__gyro-fallback', {
                property: 'rotation',
                to: '0 360 180', // Maintain top view while rotating around Y-axis
                dur: 15000,
                loop: true,
                easing: 'linear'
            });

            console.log('Using fallback rotation animation');
        }

        // Stop gyroscope rotation (when model is hidden)
        function stopGyroscopeRotation() {
            if (gyroscopeActive) {
                window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
                gyroscopeActive = false;
                console.log('Gyroscope rotation disabled');
            }
        }

        // Place model on QR location (persistent until next QR detection)
        function createDynamicARMarker(location) {
            if (!arModel) return;

            // Only reposition if model is not already fixed in place
            if (!modelFixed) {
                // Calculate QR center position
                const centerX = (location.topLeftCorner.x + location.topRightCorner.x) / 2;
                const centerY = (location.topLeftCorner.y + location.bottomLeftCorner.y) / 2;
                const qrWidth = location.topRightCorner.x - location.topLeftCorner.x;

                // Convert screen coordinates to world coordinates
                const normalizedX = (centerX / canvas.width - 0.5) * 2;
                const normalizedY = -(centerY / canvas.height - 0.5) * 2;

                // Calculate distance for optimal visibility
                const distance = Math.max(1.2, 180 / qrWidth);

                // Position in 3D world - QR code as base
                const worldX = normalizedX * 0.4;
                const worldY = normalizedY * 0.4;
                const worldZ = -distance;

                // Store world position for tracking
                arModel.worldPosition = { x: worldX, y: worldY, z: worldZ };

                // Position and show the 3D model (bottom sits on QR)
                arModel.setAttribute('position', `${worldX} ${worldY} ${worldZ}`);
                arModel.setAttribute('visible', 'true');

                // Mark model as fixed in place
                modelFixed = true;
                qrModelVisible = true;

                // Start animation update loop for video textures
                startAnimationUpdateLoop();

                // Enable AR world tracking
                enableARWorldTracking();

                console.log(`3D Model fixed at QR location: ${worldX}, ${worldY}, ${worldZ}`);
            }

            // Clear any overlay elements (no dot, no text)
            document.getElementById('qr-overlay').innerHTML = '';
        }

        // QR Code detection function with memory optimization
        function detectQR() {
            if (!qrDetectionActive || !videoElement) {
                requestAnimationFrame(detectQR);
                return;
            }

            try {
                // Limit canvas size for memory efficiency
                const maxWidth = 640;
                const maxHeight = 480;

                canvas.width = Math.min(videoElement.videoWidth, maxWidth);
                canvas.height = Math.min(videoElement.videoHeight, maxHeight);

                if (canvas.width > 0 && canvas.height > 0) {
                    context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

                    // Only process every other frame to reduce memory usage
                    if (Date.now() % 2 === 0) {
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                        if (typeof jsQR !== 'undefined') {
                            const code = jsQR(imageData.data, imageData.width, imageData.height);

                            if (code) {
                                console.log('QR Code detected:', code.data);
                                showQRDetection(code.location);
                                showARModelOnQR(code.location);
                            } else {
                                // Don't hide model when QR is lost - keep it persistent
                                hideQRDetection();
                                // Model stays visible and fixed in place
                            }
                        }
                    }
                }
            } catch (error) {
                console.log('QR detection error:', error);
            }

            // Reduce frame rate to save memory
            setTimeout(() => {
                requestAnimationFrame(detectQR);
            }, 50); // ~20 FPS instead of 60 FPS
        }

        function showQRDetection(location) {
            // Now we'll create a proper AR marker at the QR location
            createDynamicARMarker(location);
        }

        function hideQRDetection() {
            document.getElementById('qr-overlay').innerHTML = '';
            // Model stays visible and fixed - no hiding when QR is lost
        }

        function showARModelOnQR(location) {
            // Reset model position when new QR is detected
            if (modelFixed) {
                modelFixed = false; // Allow repositioning for new QR detection
                console.log('New QR detected - repositioning model');
            }
        }

        function hideARModel() {
            if (qrModelVisible) {
                qrModelVisible = false;
                console.log('3D Model hidden');
            }
        }

        // Hide loader when AR is ready
        window.addEventListener('load', function () {
            const loader = document.querySelector('.arjs-loader');

            setTimeout(() => {
                if (loader) {
                    loader.style.display = 'none';
                }
                initQRDetection();
            }, 2000);
        });

        // Add marker found/lost events
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(() => {
                const markers = document.querySelectorAll('a-marker');
                markers.forEach(marker => {
                    marker.addEventListener('markerFound', function () {
                        console.log('Marker detected!');
                    });

                    marker.addEventListener('markerLost', function () {
                        console.log('Marker lost');
                    });
                });
            }, 1000);
        });
    </script>
</body>

</html>