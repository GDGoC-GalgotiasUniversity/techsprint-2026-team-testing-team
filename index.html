<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        a-scene, .a-canvas, canvas {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 10 !important;
            pointer-events: none !important;
        }
        /* Removed invalid 'visible' property. No effect in CSS. */
        #dynamic-qr-3d-model, [gltf-model] {
            /* No CSS visibility override needed for A-Frame entities */
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        .arjs-loader {
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .arjs-loader div {
            text-align: center;
            font-size: 1.25em;
            color: white;
        }

        .arjs-loader-text {
            font-size: 0.75em;
            margin-top: 0.5em;
        }

        #qr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .qr-detected {
            position: absolute;
            border: 3px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        /* Full responsive video and canvas coverage */
        video {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            object-fit: cover !important;
            object-position: center !important;
            z-index: -1 !important;
            transform: none !important;
            border: none !important;
            outline: none !important;
        }

        canvas {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            object-fit: cover !important;
            object-position: center !important;
            border: none !important;
            outline: none !important;
        }

        a-scene {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            overflow: hidden !important;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            z-index: 2 !important;
        }

        /* Universal responsive coverage for all devices */
        @media screen {
            * {
                box-sizing: border-box !important;
            }

            html,
            body {
                width: 100vw !important;
                height: 100vh !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
                background: #000 !important;
                position: relative !important;
            }

            video,
            canvas,
            a-scene {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                min-width: 100vw !important;
                min-height: 100vh !important;
                max-width: none !important;
                max-height: none !important;
                border: none !important;
                outline: none !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            video {
                object-fit: cover !important;
                object-position: center center !important;
                z-index: -1 !important;
            }

            canvas {
                object-fit: cover !important;
                object-position: center center !important;
            }
        }

        /* Mobile phones - extra coverage insurance */
        @media screen and (max-width: 480px) {
            video {
                transform: scale(1.05) !important;
                /* Slight zoom to ensure no gaps */
                transform-origin: center center !important;
            }
        }

        /* Tablets and larger phones */
        @media screen and (min-width: 481px) and (max-width: 1024px) {
            video {
                transform: scale(1.02) !important;
                /* Minimal zoom for coverage */
                transform-origin: center center !important;
            }
        }

        /* Desktop and large screens */
        @media screen and (min-width: 1025px) {
            video {
                transform: none !important;
            }
        }

        /* Orientation-specific adjustments */
        @media screen and (orientation: landscape) and (max-width: 1024px) {
            video {
                width: 100vw !important;
                height: 100vh !important;
                object-fit: cover !important;
            }
        }

        @media screen and (orientation: portrait) and (max-width: 1024px) {
            video {
                width: 100vw !important;
                height: 100vh !important;
                object-fit: cover !important;
            }
        }
    </style>
</head>

<body style="margin: 0px; overflow: hidden;">
    <div class="arjs-loader">
        <div>
            <div>Loading AR Camera...</div>
            <div class="arjs-loader-text">Point your camera at any QR code to see the 3D model</div>
        </div>
    </div>

    <!-- Gyroscope permission button (iOS) -->
    <div id="gyro-permission"
        style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; text-align: center;">
        <div style="color: white; margin-bottom: 15px;">Enable device rotation for better AR experience?</div>
        <button id="enable-gyro"
            style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Enable
            Rotation</button>
        <button id="skip-gyro"
            style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Skip</button>
    </div>

    <!-- QR Detection Overlay -->
    <div id="qr-overlay"></div>

    <!-- Manual Camera Activation Button -->
    <button id="activate-camera"
        style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10000; padding: 20px 40px; background: #28a745; color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
        ðŸŽ¥ Start Camera
    </button>

    <a-scene vr-mode-ui="enabled: false;" renderer="logarithmicDepthBuffer: true;" embedded
        arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; sourceWidth: 640; sourceHeight: 480; displayWidth: 640; displayHeight: 480; videoTexture: false;"
        style="width: 100vw; height: 100vh; background: transparent;">

        <!-- Multiple barcode markers for different QR codes -->
        <a-marker type="barcode" value="0">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="1 1 1" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="1">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <a-marker type="barcode" value="2">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Hiro marker for testing -->
        <a-marker preset="hiro">
            <a-entity gltf-model="./officeman_laptop_2.glb" scale="0.15 0.15 0.15" position="0 0.3 0" rotation="-90 0 0"
                animation-mixer>
            </a-entity>
        </a-marker>

        <!-- Camera with AR.js built-in tracking -->
        <a-entity id="ar-camera" camera="fov: 80; near: 0.05; far: 2000"></a-entity>
    </a-scene>

    <script>
        // Add global error handling for A-Frame systems
        window.addEventListener('error', function (e) {
            // Only suppress known A-Frame system errors, not AR.js marker material warnings
            if (e.message && (e.message.includes('systems') || e.message.includes('Cannot read properties of null'))) {
                console.log('A-Frame initialization error caught and handled:', e.message);
                e.preventDefault();
                return false;
            }
        });

        // Patch AR.js to avoid setting 'markersAreaEnabled' on marker materials (prevents warning spam)
        AFRAME.registerComponent('fix-arjs-marker-material', {
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    const mesh = this.el.getObject3D('mesh');
                    if (mesh) {
                        mesh.traverse(child => {
                            if (child.material && child.material.markersAreaEnabled !== undefined) {
                                // Remove the property to prevent AR.js from trying to set it
                                delete child.material.markersAreaEnabled;
                            }
                        });
                    }
                });
            }
        });


        // Allow A-Frame and AR.js to initialize as normal so the AR scene and model rendering works

        let qrDetectionActive = false;
        let videoElement = null;
        let canvas = null;
        let context = null;
        let arModel = null;
        let qrModelVisible = false;
        let modelFixed = false; // Track if model is already placed and fixed
        let animationUpdateLoop = null; // Animation update loop
        let gyroscopeActive = false; // Track gyroscope status
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 }; // Device orientation data
        let cameraEntity = null; // Reference to camera entity
        let markerTrackingActive = false; // Track if marker-based AR is active
        let virtualMarker = null; // Virtual marker for AR tracking
        let deviceZoomLevel = 0.3; // Dynamic zoom level based on device

        // Detect device type and set appropriate zoom level
        function detectDeviceAndSetZoom() {
            const userAgent = navigator.userAgent.toLowerCase();
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const pixelRatio = window.devicePixelRatio || 1;

            console.log(`Device info: ${screenWidth}x${screenHeight}, ratio: ${pixelRatio}, UA: ${userAgent.substring(0, 50)}...`);

            // iPhone specific adjustments
            if (userAgent.includes('iphone')) {
                if (screenWidth >= 414) { // iPhone Plus/Pro Max models
                    deviceZoomLevel = 0.15; // Very zoomed out
                } else if (screenWidth >= 375) { // iPhone 6/7/8/X/11/12/13 standard
                    deviceZoomLevel = 0.2; // Moderately zoomed out
                } else { // iPhone SE and older
                    deviceZoomLevel = 0.25; // Less zoomed out
                }
            }
            // iPad adjustments
            else if (userAgent.includes('ipad')) {
                deviceZoomLevel = 0.4; // iPads need less zoom out
            }
            // Samsung Galaxy adjustments
            else if (userAgent.includes('samsung') || userAgent.includes('galaxy')) {
                if (screenWidth >= 480) { // Large Samsung phones
                    deviceZoomLevel = 0.1; // Extremely zoomed out
                } else if (screenWidth >= 360) { // Standard Samsung phones
                    deviceZoomLevel = 0.15; // Very zoomed out
                } else { // Smaller Samsung phones
                    deviceZoomLevel = 0.2; // Moderately zoomed out
                }
            }
            // Google Pixel adjustments
            else if (userAgent.includes('pixel')) {
                deviceZoomLevel = 0.15; // Pixels tend to zoom in a lot
            }
            // OnePlus adjustments
            else if (userAgent.includes('oneplus')) {
                deviceZoomLevel = 0.12; // OnePlus phones zoom in significantly
            }
            // Xiaomi adjustments
            else if (userAgent.includes('xiaomi') || userAgent.includes('mi ')) {
                deviceZoomLevel = 0.18; // Xiaomi phones need aggressive zoom out
            }
            // Huawei adjustments
            else if (userAgent.includes('huawei')) {
                deviceZoomLevel = 0.16; // Huawei phones zoom in quite a bit
            }
            // Realme adjustments
            else if (userAgent.includes('realme')) {
                if (screenWidth >= 480) { // Realme Pro/flagship models
                    deviceZoomLevel = 0.08; // Extremely zoomed out - Realme zooms in heavily
                } else if (screenWidth >= 360) { // Standard Realme phones
                    deviceZoomLevel = 0.12; // Very zoomed out
                } else { // Budget Realme phones
                    deviceZoomLevel = 0.18; // Moderately zoomed out
                }
            }
            // High pixel density devices (general)
            else if (pixelRatio >= 3) {
                deviceZoomLevel = 0.1; // Very high DPI devices need extreme zoom out
            }
            else if (pixelRatio >= 2) {
                deviceZoomLevel = 0.2; // High DPI devices need significant zoom out
            }
            // Large screen devices
            else if (screenWidth >= 480) {
                deviceZoomLevel = 0.15; // Large screens often zoom in too much
            }
            // Small screen devices
            else if (screenWidth <= 320) {
                deviceZoomLevel = 0.35; // Small screens need less zoom out
            }
            // Default for unknown devices
            else {
                deviceZoomLevel = 0.25; // Conservative default
            }

            console.log(`Selected zoom level: ${deviceZoomLevel}`);
        }

        // Update AR.js configuration based on screen size
        function updateARJSConfiguration() {
            const scene = document.querySelector('a-scene');
            const screenWidth = window.innerWidth || document.documentElement.clientWidth;
            const screenHeight = window.innerHeight || document.documentElement.clientHeight;

            // Calculate optimal source dimensions based on screen size
            const sourceWidth = Math.max(screenWidth, 1280);
            const sourceHeight = Math.max(screenHeight, 960);

            // Disabled to prevent systems errors
            // if (scene) {
            //     scene.setAttribute('arjs',
            //         `trackingMethod: best; sourceType: webcam; debugUIEnabled: false; sourceWidth: ${sourceWidth}; sourceHeight: ${sourceHeight}; displayWidth: ${sourceWidth}; displayHeight: ${sourceHeight};`
            //     );
            //     console.log(`Updated AR.js configuration to: ${sourceWidth}x${sourceHeight}`);
            // }
            console.log('AR.js configuration skipped to prevent systems errors');
        }

        // Force full screen coverage for all devices
        function forceFullScreenCoverage() {
            const videoElement = document.querySelector('video');
            const canvasElement = document.querySelector('canvas');
            const sceneElement = document.querySelector('a-scene');

            // Force all video elements to be visible and cover full screen
            const videoElements = document.querySelectorAll('video');
            console.log(`Found ${videoElements.length} video elements to configure`);

            videoElements.forEach((video, index) => {
                video.style.display = 'block';
                video.style.visibility = 'visible';
                video.style.opacity = '1';
                video.style.position = 'fixed';
                video.style.top = '0';
                video.style.left = '0';
                video.style.right = '0';
                video.style.bottom = '0';
                video.style.width = '100vw';
                video.style.height = '100vh';
                video.style.minWidth = '100vw';
                video.style.minHeight = '100vh';
                video.style.maxWidth = 'none';
                video.style.maxHeight = 'none';
                video.style.objectFit = 'cover';
                video.style.objectPosition = 'center center';
                video.style.zIndex = index === 0 ? '-1' : '-2'; // First video on top
                video.style.border = 'none';
                video.style.outline = 'none';
                video.style.margin = '0';
                video.style.padding = '0';

                // Add slight scale for mobile to ensure no gaps
                const isMobile = window.innerWidth <= 1024;
                if (isMobile) {
                    video.style.transform = 'scale(1.05)';
                    video.style.transformOrigin = 'center center';
                }

                // Ensure video is playing
                if (video.paused) {
                    video.play().catch(e => console.log('Video play error:', e));
                }
            });
}
            // Force canvas full coverage
          


        // Monitor only our main camera video (not AR.js videos)
        function monitorVideoElements() {
            const mainVideo = document.getElementById('main-camera-video');

            if (!mainVideo) {
                console.log('Main camera video not found');
                return;
            }

           
            // Debug info
            const isVisible = mainVideo.style.display !== 'none' &&
                mainVideo.style.visibility !== 'hidden' &&
                mainVideo.style.opacity !== '0';

            console.log('Main video forced visible:', isVisible);

            // Ensure main video stays playing
            if (mainVideo.paused && mainVideo.readyState >= 2) {
                mainVideo.play().catch(e => console.log('Main video play failed:', e));
            }

            // Remove any AR.js videos that might interfere
            const otherVideos = document.querySelectorAll('video:not(#main-camera-video)');
            otherVideos.forEach(video => {
                console.log('Removing interfering AR.js video');
                video.remove();
            });
        }

        // Handle orientation changes properly without exponential growth
        function handleOrientationChange() {
            setTimeout(() => {
                // Don't call forceFullScreenCoverage - it causes black screen
                console.log('Orientation changed - video monitoring only');
                monitorVideoElements(); // Just monitor video instead
            }, 100);
        }

        // Initialize QR detection with device-specific camera settings
        function initQRDetection() {
            // Skip AR.js configuration update to avoid systems error
            console.log('Initializing QR detection...');

            // Detect device and set appropriate zoom level
            detectDeviceAndSetZoom();

            // Add orientation change handler
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleOrientationChange);

            // Start continuous monitoring for responsive coverage
            setInterval(() => {
                forceFullScreenCoverage();
            }, 2000); // Check every 2 seconds

            // Request camera permission first
            requestCameraPermission();

            // Request wide-angle camera
            setTimeout(() => {
                requestHighQualityCamera();
            }, 1000);

            setTimeout(() => {
                // Try multiple ways to find the video element
                videoElement = document.querySelector('video') ||
                    document.querySelector('a-scene video') ||
                    document.querySelector('[arjs] video');

                // If still no video, wait for AR.js to create it
                if (!videoElement) {
                    console.log('Video element not found, waiting for AR.js...');
                    setTimeout(() => {
                        videoElement = document.querySelector('video');
                        if (videoElement) {
                            setupVideoElement();
                        } else {
                            console.log('Video element still not found after delay');
                            // Force create video element if AR.js hasn't
                            createFallbackVideo();
                        }
                    }, 2000);
                    return;
                }

                setupVideoElement();
            }, 3000);
        }

        // Setup video element with proper styling
        function setupVideoElement() {
            if (!videoElement) return;

            console.log('Setting up video element:', videoElement);

            // Detect if mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            if (isMobile) {
                // Mobile-specific video setup
                videoElement.setAttribute('width', '640');
                videoElement.setAttribute('height', '480');
                videoElement.style.position = 'fixed';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.width = '100vw';
                videoElement.style.height = '100vh';
                videoElement.style.minWidth = '100vw';
                videoElement.style.minHeight = '100vh';
                videoElement.style.maxWidth = 'none';
                videoElement.style.maxHeight = 'none';
                videoElement.style.objectFit = 'cover';
                videoElement.style.zIndex = '-1';
                videoElement.style.transform = 'none';

                // Force viewport meta tag for mobile
                let viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
                }

                console.log('Applied mobile-specific video settings');
            } else {
                // Desktop setup
                videoElement.setAttribute('width', '1920');
                videoElement.setAttribute('height', '1080');
                videoElement.style.objectFit = 'cover';
                videoElement.style.width = '100vw';
                videoElement.style.height = '100vh';
                videoElement.style.maxWidth = '100vw';
                videoElement.style.maxHeight = '100vh';
                videoElement.style.position = 'fixed';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.zIndex = '-1';
            }

            // Apply device-specific camera settings via AR.js instead of CSS transforms
            updateARCameraSettings(deviceZoomLevel);

            // Don't force full screen coverage - it causes black screen
            // Just rely on CSS and video monitoring instead

            console.log(`Applied video settings for device: ${navigator.userAgent.substring(0, 50)}...`);

            canvas = document.createElement('canvas');
            context = canvas.getContext('2d', { willReadFrequently: true });

            // Wait for A-Frame to be fully ready before creating AR model
            setTimeout(() => {
                createQRARModel();
            }, 1000);

            // Get camera entity reference
            cameraEntity = document.querySelector('#ar-camera');

            qrDetectionActive = true;
            detectQR();
        }

        // Create fallback video if AR.js doesn't create one
        function createFallbackVideo() {
            console.log('Creating fallback video element');

            // Create video element
            videoElement = document.createElement('video');
            videoElement.setAttribute('autoplay', 'true');
            videoElement.setAttribute('muted', 'true');
            videoElement.setAttribute('playsinline', 'true');
            videoElement.style.position = 'fixed';
            videoElement.style.top = '0';
            videoElement.style.left = '0';
            videoElement.style.width = '100vw';
            videoElement.style.height = '100vh';
            videoElement.style.objectFit = 'cover';
            videoElement.style.zIndex = '-1';

            // Add to DOM
            document.body.appendChild(videoElement);

            // Request camera access
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                })
                    .then(function (stream) {
                        videoElement.srcObject = stream;
                        videoElement.play();
                        console.log('Fallback video stream started');
                        setupVideoElement();
                    })
                    .catch(function (error) {
                        console.error('Error accessing camera for fallback video:', error);
                    });
            }
        }

        // Enhanced force full screen coverage
        function forceVideoVisibility() {
            const videos = document.querySelectorAll('video');
            console.log(`Found ${videos.length} video elements`);

            videos.forEach((video, index) => {
                console.log(`Configuring video ${index}:`, video);
                video.style.display = 'block';
                video.style.visibility = 'visible';
                video.style.opacity = '1';
                video.style.position = 'fixed';
                video.style.top = '0';
                video.style.left = '0';
                video.style.width = '100vw';
                video.style.height = '100vh';
                video.style.objectFit = 'cover';
                video.style.zIndex = index === 0 ? '-1' : '-2'; // First video on top
                video.style.transform = 'none';

                // Ensure video is playing
                if (video.paused) {
                    video.play().catch(e => console.log('Video play failed:', e));
                }
            });
        }

        // Update the existing initQRDetection function
        function initQRDetection() {
            // Update AR.js configuration for current screen
            updateARJSConfiguration();

            // Detect device and set appropriate zoom level
            detectDeviceAndSetZoom();

            // Add orientation change handler
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleOrientationChange);

            // Start monitoring with higher frequency to keep video visible
            setInterval(() => {
                monitorVideoElements(); // Keep video visible during QR detection
                // Don't call forceFullScreenCoverage - it causes black screen
            }, 500); // Check every 500ms to ensure video stays visible

            // Request wide-angle camera first
            requestHighQualityCamera();

            // Start video detection process
            if (videoElement) {
                // Detect if mobile device
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                if (isMobile) {
                    // Mobile-specific video setup
                    videoElement.setAttribute('width', '640');
                    videoElement.setAttribute('height', '480');
                    videoElement.style.position = 'fixed';
                    videoElement.style.top = '0';
                    videoElement.style.left = '0';
                    videoElement.style.width = '100vw';
                    videoElement.style.height = '100vh';
                    videoElement.style.minWidth = '100vw';
                    videoElement.style.minHeight = '100vh';
                    videoElement.style.maxWidth = 'none';
                    videoElement.style.maxHeight = 'none';
                    videoElement.style.objectFit = 'cover';
                    videoElement.style.zIndex = '-1';
                    videoElement.style.transform = 'none';

                    // Force viewport meta tag for mobile
                    let viewport = document.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
                    }

                    console.log('Applied mobile-specific video settings');
                } else {
                    // Desktop setup
                    videoElement.setAttribute('width', '1920');
                    videoElement.setAttribute('height', '1080');
                    videoElement.style.objectFit = 'cover';
                    videoElement.style.width = '100vw';
                    videoElement.style.height = '100vh';
                    videoElement.style.maxWidth = '100vw';
                    videoElement.style.maxHeight = '100vh';
                    videoElement.style.position = 'fixed';
                    videoElement.style.top = '0';
                    videoElement.style.left = '0';
                    videoElement.style.zIndex = '-1';
                }

                // Apply device-specific camera settings via AR.js instead of CSS transforms
                updateARCameraSettings(deviceZoomLevel);

                // Don't force full screen coverage - it causes black screen
                // Video is already properly styled with CSS

                console.log(`Applied video settings for device: ${navigator.userAgent.substring(0, 50)}...`);

                canvas = document.createElement('canvas');
                context = canvas.getContext('2d', { willReadFrequently: true });

                // Wait for A-Frame to be fully ready before creating AR model
                setTimeout(() => {
                    createQRARModel();
                }, 1000);

                // Get camera entity reference
                cameraEntity = document.querySelector('#ar-camera');

                qrDetectionActive = true;
                detectQR();
            }
        } 3000

        // Update AR camera settings without interfering with viewport
        function updateARCameraSettings(zoomLevel) {
            try {
                const scene = document.querySelector('a-scene');
                const camera = document.querySelector('#ar-camera');

                // Disabled to prevent systems errors
                // if (camera && camera.setAttribute) {
                //     // Calculate appropriate FOV based on zoom level (inverse relationship)
                //     const baseFOV = 80; // Standard FOV
                //     const adjustedFOV = baseFOV + (zoomLevel * 200); // Higher zoom = wider FOV

                //     // Update camera FOV instead of using CSS transforms
                //     camera.setAttribute('camera', `fov: ${adjustedFOV}; near: 0.05; far: 2000`);

                //     console.log(`Updated camera FOV to ${adjustedFOV}Â° for zoom level ${zoomLevel}`);
                // } else {
                //     console.log('Camera element not ready yet');
                // }
                console.log('Camera FOV update skipped to prevent systems errors');

                // Update AR.js source settings for better tracking
                if (scene && scene.getAttribute && scene.setAttribute) {
                    const currentArjs = scene.getAttribute('arjs');
                    if (currentArjs && typeof currentArjs === 'string') {
                        const updatedArjs = currentArjs.replace(/sourceWidth: \d+/, `sourceWidth: ${Math.floor(640 * (1 + zoomLevel))}`);
                        scene.setAttribute('arjs', updatedArjs);
                    }
                } else {
                    console.log('Scene element not ready yet');
                }
            } catch (error) {
                console.log('Error updating AR camera settings:', error);
            }
        }

        // Create and display camera video directly (bypassing AR.js video creation)
        function requestCameraPermission() {
            console.log('Creating direct camera video...');

            // Remove ALL existing videos to prevent conflicts
            const existingVideos = document.querySelectorAll('video');
            existingVideos.forEach(video => {
                console.log('Removing existing video element to prevent conflicts');
                video.remove();
            });

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 720, min: 480 }
                    }
                })
                    .then(function (stream) {
                        console.log('Camera stream obtained successfully');

                        // Create new video element
                        const video = document.createElement('video');
                        video.id = 'main-camera-video';
                        video.setAttribute('autoplay', 'true');
                        video.setAttribute('muted', 'true');
                        video.setAttribute('playsinline', 'true');

                        // Assign stream immediately
                        video.srcObject = stream;

                        // Style for full screen (highest priority) - make video visible
                        video.style.cssText = `
                        position: fixed !important;
                        top: 0 !important;
                        left: 0 !important;
                        width: 100vw !important;
                        height: 100vh !important;
                        object-fit: cover !important;
                        z-index: 1 !important;
                        display: block !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        background: black !important;
                        pointer-events: none !important;
                        border: 5px solid red !important;
                    `;

                        // Add to body as first element
                        document.body.insertBefore(video, document.body.firstChild);

                        // Play video and handle success
                        video.play().then(() => {
                            console.log('âœ… Video playing successfully!');
                            console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
                            videoElement = video;

                            // Hide the activate button
                            const button = document.getElementById('activate-camera');
                            if (button) button.style.display = 'none';

                            // Add debug overlay to confirm video is working
                            const debugDiv = document.createElement('div');
                            debugDiv.innerHTML = 'ðŸ“¹ Camera Active - Video Playing!';
                            debugDiv.style.cssText = `
                                position: fixed;
                                top: 20px;
                                left: 20px;
                                background: rgba(0,255,0,0.8);
                                color: white;
                                padding: 10px;
                                border-radius: 5px;
                                z-index: 10000;
                                font-weight: bold;
                            `;
                            document.body.appendChild(debugDiv);

                            // Remove debug overlay after 3 seconds
                            setTimeout(() => {
                                if (debugDiv.parentNode) {
                                    debugDiv.parentNode.removeChild(debugDiv);
                                }
                            }, 3000);

                            // Start QR detection
                            // Re-enable QR detection now that camera is stable
                            setTimeout(() => {
                                if (!qrDetectionActive) {
                                    console.log('Starting QR detection...');
                                    qrDetectionActive = true;
                                    detectQR();
                                }
                            }, 2000); // Wait 2 seconds for camera to stabilize

                        }).catch(error => {
                            console.error('âŒ Video play failed:', error);
                        });

                        // Add event listeners for debugging
                        video.addEventListener('loadedmetadata', () => {
                            console.log('Video metadata loaded:', video.videoWidth, 'x', video.videoHeight);
                        });

                        video.addEventListener('canplay', () => {
                            console.log('Video can play');
                        });
                    })
                    .catch(function (error) {
                        console.error('âŒ Camera access failed:', error);
                        alert('Camera access denied. Please allow camera access and click "Activate Camera" button.');
                    });
            } else {
                console.error('getUserMedia not supported');
                alert('Your browser does not support camera access.');
            }
        }

        // Request wide-angle camera stream (simplified constraints)
        function requestHighQualityCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const constraints = {
                    video: {
                        width: { ideal: 1280, min: 640 },
                        height: { ideal: 960, min: 480 },
                        facingMode: { ideal: 'environment' }, // Back camera
                        frameRate: { ideal: 30, min: 15 },
                        aspectRatio: { ideal: 4 / 3 }
                    }
                };

                navigator.mediaDevices.getUserMedia(constraints)
                    .then(function (stream) {
                        console.log('Wide-angle camera stream obtained');

                        // Try to apply basic settings without zoom constraints
                        const videoTrack = stream.getVideoTracks()[0];
                        if (videoTrack && videoTrack.applyConstraints) {
                            videoTrack.applyConstraints({
                                focusMode: 'continuous'
                            }).catch(err => console.log('Focus constraint failed:', err));
                        }
                    })
                    .catch(function (error) {
                        console.log('Camera access error:', error);
                        // Fallback to basic constraints
                        navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: 'environment'
                            }
                        }).then(stream => {
                            console.log('Fallback camera stream obtained');
                        }).catch(err => console.log('Fallback camera failed:', err));
                    });
            }
        }

        // Create clean AR model system (5% scale, QR as base)
        function createQRARModel() {
            // Wait for A-Frame scene to be fully initialized
            const scene = document.querySelector('a-scene');

            if (!scene) {
                console.log('A-Frame scene not ready, retrying in 500ms...');
                setTimeout(createQRARModel, 500);
                return;
            }

            // Wait for scene to be loaded
            if (!scene.hasLoaded) {
                scene.addEventListener('loaded', createQRARModel);
                return;
            }

            // Create a dynamic marker that we'll position based on QR detection
            arModel = document.createElement('a-entity');
            arModel.setAttribute('id', 'dynamic-qr-3d-model');
            arModel.setAttribute('visible', 'false');


            // Add the actual GLTF model at 5% scale with correct orientation
            const gltfModel = document.createElement('a-entity');
            // Use absolute path for GLB to avoid loading issues
            const glbPath = window.location.origin + '/officeman_laptop_2.glb';
            gltfModel.setAttribute('gltf-model', glbPath);
            gltfModel.setAttribute('scale', '0.05 0.05 0.05'); // 5% scale as requested
            gltfModel.setAttribute('position', '0 0 0'); // Bottom sits on QR code (Y=0)
            gltfModel.setAttribute('rotation', '0 0 0'); // Correct orientation for top view
            // Enhanced animation-mixer for video textures and complex animations
            gltfModel.setAttribute('animation-mixer', 'clip: *; loop: repeat; timeScale: 1; crossFadeDuration: 0');

            // Add error handling for GLTF loading
            gltfModel.addEventListener('model-error', function (event) {
                console.error('GLTF model failed to load:', event.detail);
                alert('Failed to load 3D model. Check the file path and server.');
            });

            // Add error handling for GLTF loading and video texture setup
            gltfModel.addEventListener('model-loaded', function () {
                console.log('GLTF model loaded and added to scene!');
                setTimeout(() => {
                    const object3D = gltfModel.getObject3D('mesh');
                    if (object3D) {
                        // Enable video textures and animations
                        setupVideoTextures(object3D);
                        setupAnimations(gltfModel, object3D);
                    }
                }, 100);
            });

            gltfModel.addEventListener('model-error', function (event) {
                console.error('GLTF model failed to load:', event.detail);
            });

            arModel.appendChild(gltfModel);

            // Append to scene only after scene is fully loaded
            if (!scene.hasLoaded) {
                scene.addEventListener('loaded', () => {
                    scene.appendChild(arModel);
                    console.log('AR model added to scene after scene loaded');
                });
            } else {
                scene.appendChild(arModel);
                console.log('Clean AR model system initialized - 5% scale, QR as base');
            }
        }

        // Setup video textures in GLB model
        function setupVideoTextures(object3D) {
            object3D.traverse(function (child) {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];

                    materials.forEach(material => {
                        // Check for video textures
                        if (material.map && material.map.image && material.map.image.tagName === 'VIDEO') {
                            const video = material.map.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Video texture found and started');
                        }

                        // Check for emissive video textures
                        if (material.emissiveMap && material.emissiveMap.image && material.emissiveMap.image.tagName === 'VIDEO') {
                            const video = material.emissiveMap.image;
                            video.play();
                            video.loop = true;
                            video.muted = true;
                            console.log('Emissive video texture found and started');
                        }

                        // Enable video texture updates
                        if (material.map && material.map.isVideoTexture) {
                            material.map.needsUpdate = true;
                        }
                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                            material.emissiveMap.needsUpdate = true;
                        }
                    });
                }
            });
        }

        // Setup animations for GLB model
        function setupAnimations(gltfEntity, object3D) {
            // Wait a bit more for animation-mixer to initialize
            setTimeout(() => {
                const mixer = gltfEntity.components['animation-mixer'];

                if (mixer && mixer.mixer) {
                    console.log('Animation mixer found, setting up animations...');

                    // Start all animations
                    const actions = mixer.mixer._actions;
                    if (actions && actions.length > 0) {
                        actions.forEach(action => {
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity); // THREE.LoopRepeat
                            console.log('Animation started:', action._clip.name);
                        });
                        mixer.mixer.timeScale = 1;
                    } else {
                        console.log('No animation actions found, checking clips...');

                        // Try to access clips directly from the loaded model
                        if (object3D.animations && object3D.animations.length > 0) {
                            console.log('Found', object3D.animations.length, 'animation clips');

                            // Create new mixer with all clips
                            const newMixer = new THREE.AnimationMixer(object3D);
                            object3D.animations.forEach(clip => {
                                const action = newMixer.clipAction(clip);
                                action.reset();
                                action.play();
                                action.setLoop(2201, Infinity);
                                console.log('Clip started:', clip.name);
                            });

                            // Replace the mixer in the component
                            mixer.mixer = newMixer;
                            console.log('New animation mixer created with', object3D.animations.length, 'clips');
                        }
                    }
                } else {
                    console.log('No animation mixer component found, trying to create one...');

                    // Try to manually create animation mixer
                    if (object3D.animations && object3D.animations.length > 0) {
                        console.log('Creating manual animation mixer for', object3D.animations.length, 'clips');

                        const manualMixer = new THREE.AnimationMixer(object3D);
                        object3D.animations.forEach(clip => {
                            const action = manualMixer.clipAction(clip);
                            action.reset();
                            action.play();
                            action.setLoop(2201, Infinity);
                            console.log('Manual clip started:', clip.name);
                        });

                        // Store the mixer for updates
                        gltfEntity.manualMixer = manualMixer;
                    }
                }
            }, 1000);
        }

        // Start continuous update loop for animations and video textures
        function startAnimationUpdateLoop() {
            if (animationUpdateLoop) return; // Already running

            function updateLoop() {
                if (arModel && qrModelVisible) {
                    const gltfModel = arModel.querySelector('[gltf-model]');
                    if (gltfModel) {
                        // Update official animation mixer
                        const mixer = gltfModel.components['animation-mixer'];
                        if (mixer && mixer.mixer) {
                            mixer.mixer.update(0.016); // ~60fps
                        }

                        // Update manual mixer if it exists
                        if (gltfModel.manualMixer) {
                            gltfModel.manualMixer.update(0.016);
                        }

                        // Update video textures
                        const object3D = gltfModel.getObject3D('mesh');
                        if (object3D) {
                            object3D.traverse(function (child) {
                                if (child.isMesh && child.material) {
                                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                                    materials.forEach(material => {
                                        if (material.map && material.map.isVideoTexture) {
                                            material.map.needsUpdate = true;
                                        }
                                        if (material.emissiveMap && material.emissiveMap.isVideoTexture) {
                                            material.emissiveMap.needsUpdate = true;
                                        }
                                    });
                                }
                            });
                        }
                    }
                }

                animationUpdateLoop = requestAnimationFrame(updateLoop);
            }

            updateLoop();
            console.log('Animation update loop started');
        }

        // Enable marker-based AR tracking (no gyroscope needed)
        function enableMarkerARTracking() {
            if (markerTrackingActive) return; // Already active

            // Create virtual marker at QR location for AR tracking
            createVirtualMarker();
            markerTrackingActive = true;
            console.log('Marker-based AR tracking enabled - no gyroscope needed');
        }

        // Create marker-based AR tracking using AR.js
        function createVirtualMarker() {
            if (!arModel || !arModel.worldPosition) return;

            // Use AR.js built-in marker tracking - model stays world-locked
            // The AR.js system handles all the camera tracking automatically

            // Make model responsive to camera position using look-at
            arModel.setAttribute('look-at', '#ar-camera');

            // Add smooth rotation animation to make model more dynamic
            arModel.setAttribute('animation__rotate', {
                property: 'rotation',
                to: '0 360 0',
                dur: 20000,
                loop: true,
                easing: 'linear'
            });

            console.log('AR.js marker tracking enabled - model will follow camera naturally');
        }

        // Start AR world tracking with full 360Â° support
        function startARWorldTracking() {
            // Record initial orientation when model is placed
            initialOrientation = {
                alpha: deviceOrientation.alpha || 0,
                beta: deviceOrientation.beta || 0,
                gamma: deviceOrientation.gamma || 0
            };

            // Enable high-frequency orientation updates for smooth AR
            window.addEventListener('deviceorientation', handleDeviceOrientation, true);

            // Also listen for device motion for better tracking
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleDeviceMotion, true);
            }

            worldTrackingActive = true;
            console.log('AR world tracking enabled with full 360Â° support');
            console.log('Initial orientation:', initialOrientation);
        }

        // Handle device motion for enhanced AR tracking
        function handleDeviceMotion(event) {
            if (!worldTrackingActive) return;

            // Device motion can provide additional smoothing for AR tracking
            // This helps with small movements and stabilization
        }

        // Handle device orientation changes for AR world tracking
        function handleDeviceOrientation(event) {
            // Get current orientation values
            deviceOrientation.alpha = event.alpha || 0; // Z axis (compass)
            deviceOrientation.beta = event.beta || 0;   // X axis (front-back tilt)
            deviceOrientation.gamma = event.gamma || 0; // Y axis (left-right tilt)

            // Update camera to create AR world tracking effect
            if (worldTrackingActive && cameraEntity) {
                updateARCamera();
            }
        }

        // Update AR camera for full 360Â° world tracking
        function updateARCamera() {
            if (!cameraEntity || !worldTrackingActive) return;

            // Use absolute device orientation for full 360Â° tracking
            // This creates proper AR world tracking where you can walk around the model

            // Convert device orientation to camera rotation for natural AR experience
            let cameraRotationX = -deviceOrientation.beta; // Up/down tilt (invert for natural feel)
            let cameraRotationY = deviceOrientation.alpha; // Left/right rotation (compass)
            let cameraRotationZ = deviceOrientation.gamma; // Side tilt

            // Handle compass wrap-around (0Â° to 360Â°)
            if (cameraRotationY < 0) {
                cameraRotationY += 360;
            }

            // Apply sensitivity adjustments for smooth movement
            cameraRotationX *= 0.7; // Reduce up/down sensitivity slightly
            cameraRotationY *= 0.8; // Reduce left/right sensitivity slightly  
            cameraRotationZ *= 0.4; // Reduce tilt sensitivity significantly

            // Clamp extreme rotations for stability
            cameraRotationX = Math.max(-85, Math.min(85, cameraRotationX)); // Prevent over-tilting

            // Update camera rotation for full AR world tracking
            cameraEntity.setAttribute('rotation', `${cameraRotationX} ${cameraRotationY} ${cameraRotationZ}`);

            // Debug log for troubleshooting (remove in production)
            if (Math.random() < 0.01) { // Log occasionally to avoid spam
                console.log(`Camera rotation: X:${cameraRotationX.toFixed(1)}Â° Y:${cameraRotationY.toFixed(1)}Â° Z:${cameraRotationZ.toFixed(1)}Â°`);
            }
        }

        // Model uses AR.js built-in tracking - no manual rotation needed
        function updateModelRotation() {
            // AR.js handles all tracking automatically
            // Model stays world-locked using AR.js marker system
            // look-at component makes model face camera naturally
            return;
        }

        // Fallback rotation if gyroscope is not available
        function addFallbackRotation() {
            if (!arModel) return;

            // Set base rotation for top-down view, then add rotation animation
            arModel.setAttribute('rotation', ' 0 180'); // Top-down view first
            arModel.setAttribute('animation__gyro-fallback', {
                property: 'rotation',
                to: '0 360 180', // Maintain top view while rotating around Y-axis
                dur: 15000,
                loop: true,
                easing: 'linear'
            });

            console.log('Using fallback rotation animation');
        }

        // Stop gyroscope rotation (when model is hidden)
        function stopGyroscopeRotation() {
            if (gyroscopeActive) {
                window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
                gyroscopeActive = false;
                console.log('Gyroscope rotation disabled');
            }
        }

        // Place model on QR location (persistent until next QR detection)
        function createDynamicARMarker(location) {
            if (!arModel) return;
            // DEBUG: Force model to a fixed visible position and scale
            arModel.setAttribute('position', '0 0 -2');
            arModel.setAttribute('scale', '0.5 0.5 0.5');
            arModel.setAttribute('visible', 'true');
            arModel.worldPosition = { x: 0, y: 0, z: -2 };
            qrModelVisible = true;
            startAnimationUpdateLoop();
            console.log('DEBUG: 3D Model forced to position 0 0 -2, scale 0.5');
            // Clear any overlay elements (no dot, no text)
            document.getElementById('qr-overlay').innerHTML = '';
        }

        // QR Code detection function with memory optimization
        function detectQR() {
            if (!qrDetectionActive || !videoElement) {
                requestAnimationFrame(detectQR);
                return;
            }

            try {
                // Ensure canvas exists and is visible for debugging
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    context = canvas.getContext('2d', { willReadFrequently: true });
                    canvas.id = 'qr-debug-canvas';
                    canvas.style.position = 'fixed';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '320px';
                    canvas.style.height = '240px';
                    canvas.style.zIndex = '10001';
                    canvas.style.border = '2px solid red';
                    canvas.style.background = 'rgba(0,0,0,0.2)';
                    document.body.appendChild(canvas);
                    console.log('Created visible canvas for QR detection');
                }

                // Limit canvas size for memory efficiency
                const maxWidth = 640;
                const maxHeight = 480;

                // Ensure video has dimensions before setting canvas size
                if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                    canvas.width = Math.min(videoElement.videoWidth, maxWidth);
                    canvas.height = Math.min(videoElement.videoHeight, maxHeight);
                } else {
                    // Use default dimensions if video dimensions not available
                    canvas.width = maxWidth;
                    canvas.height = maxHeight;
                }

                if (canvas.width > 0 && canvas.height > 0) {
                    // Ensure video stays visible before drawing to canvas
                    const mainVideo = document.getElementById('main-camera-video');
                    if (mainVideo) {
                        mainVideo.style.display = 'block';
                        mainVideo.style.visibility = 'visible';
                        mainVideo.style.opacity = '1';
                    }

                    context.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

                    // Only process every other frame to reduce memory usage
                    if (Date.now() % 2 === 0) {
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);

                        if (typeof jsQR !== 'undefined') {
                            const code = jsQR(imageData.data, imageData.width, imageData.height);

                            if (code) {
                                console.log('QR Code detected:', code.data);
                                showQRDetection(code.location);
                                showARModelOnQR(code.location);
                            } else {
                                // Don't hide model when QR is lost - keep it persistent
                                hideQRDetection();
                                // Model stays visible and fixed in place
                            }
                        }
                    }
                }
            } catch (error) {
                console.log('QR detection error:', error);
            }

            // Reduce frame rate to save memory
            setTimeout(() => {
                requestAnimationFrame(detectQR);
            }, 50); // ~20 FPS instead of 60 FPS
        }

        function showQRDetection(location) {
            // Now we'll create a proper AR marker at the QR location
            createDynamicARMarker(location);
        }

        function hideQRDetection() {
            document.getElementById('qr-overlay').innerHTML = '';
            // Model stays visible and fixed - no hiding when QR is lost
        }

        function showARModelOnQR(location) {
            // Always allow repositioning and force model visible on every QR detection
            modelFixed = false;
            if (arModel) {
                arModel.setAttribute('visible', 'true');
                if (arModel.object3D) arModel.object3D.visible = true;
                // Also force the scene canvas to be visible and on top
                const scene = document.querySelector('a-scene');
                if (scene && scene.canvas) {
                    scene.canvas.style.zIndex = '10';
                    scene.canvas.style.display = 'block';
                    scene.canvas.style.visibility = 'visible';
                    scene.canvas.style.opacity = '1';
                }
                console.log('QR detected - model forced visible and will be repositioned');
            }
        }

        function hideARModel() {
            if (qrModelVisible) {
                qrModelVisible = false;
                console.log('3D Model hidden');
            }
        }

        // Hide loader when AR is ready
        window.addEventListener('load', function () {
            const loader = document.querySelector('.arjs-loader');

            setTimeout(() => {
                if (loader) {
                    loader.style.display = 'none';
                }
                // Don't call initQRDetection here - it's already called by the main DOMContentLoaded handler
                // But do force video visibility after loader is hidden
                setTimeout(() => {
                    monitorVideoElements();
                    // Don't call forceFullScreenCoverage - it causes black screen
                }, 500);
            }, 2000);
        });

        // Add manual camera activation button
        document.addEventListener('DOMContentLoaded', function () {
            const activateButton = document.getElementById('activate-camera');
            if (activateButton) {
                activateButton.addEventListener('click', function () {
                    console.log('Manual camera activation clicked');
                    requestCameraPermission();
                    // Hide button after click
                    activateButton.style.display = 'none';
                });
            }

            // Add marker found/lost events
            setTimeout(() => {
                const markers = document.querySelectorAll('a-marker');
                markers.forEach(marker => {
                    marker.addEventListener('markerFound', function () {
                        console.log('Marker detected!');
                    });

                    marker.addEventListener('markerLost', function () {
                        console.log('Marker lost');
                    });
                });
            }, 1000);
        });
    </script>
</body>

</html>